# 汇编语言

# 第一章 基础知识
## 1.1 机器语言
* 机器语言：机器指令的集合
* 机器指令：机器执行的命令
* 电子计算机的机器指令：二进制数，驱动电子器件的高低电平
* 不同微处理器的硬件设计和内部结构不同，需要不同的电平脉冲驱动
* 每一种微处理器有自己的机器指令集，即机器语言
## 1.2 汇编语言的产生
- 汇编语言的核心是汇编指令
- 汇编指令是机器指令便于记忆的书写格式
- 汇编编译器：汇编码 ==> 编译 ==> 机器码
## 1.3 汇编语言的组成
- 汇编指令：机器码的助记符，有对应的机器码
- 伪指令：没有对应的机器码，编译器执行，计算机不执行
- 其他符号：+, -, *, / 等，编译器识别，没有对应的机器码

## 1.4 存储器
## 1.5 指令和数据
- CPU的工作需要指令和数据
- 指令和数据存放于存储器中
- 存储器中指令和数据没有区别，均为二进制信息

## 1.6 存储单元
- 存储器被划分为若干存储单元，从0开始顺序编号
- 微机存储器的存储单元为字节，即8个二进制位
- 字节是存储器容量的最小单位
- 1KB = 1024B, 1MB = 1024KB, 1GB = 1024MB, 1TB = 1024GB
## 1.7 CPU对存储器的读写
- CPU读写数据必须与外部器件（芯片）进行3类信息的交互
    - 地址信息：存储单元的地址
    - 控制信息：器件的选择，读或写的命令
    - 数据信息：读或写的数据
- 总线 = 地址总线 + 控制总线 + 数据总线
- CPU芯片的管脚和总线相连，管脚引出总线
## 1.8 地址总线
- 地址总线的宽度决定CPU的寻址能力
- CPU有N根地址线 ==> CPU的地址总线宽度为N ==> CPU最多寻址2^N个内存单元
## 1.9 数据总线
- 数据总线的宽度决定CPU与外界的数据传输速度
## 1.10 控制总线
- 控制总线是不同控制线的集合
- 控制总线的宽度决定CPU对外部器件的控制能力
## 1.11 内存地址空间
- CPU可寻址到的所有内存单元构成CPU的内存地址空间
## 1.12 主板
## 1.13 接口卡
- CPU不能直接控制外部设备
- CPU通过总线直接控制接口卡，间接控制外部设备
## 1.14 存储器
- RAM
- 装有BIOS(Basic Input/Ouput System, 基本输入/输出系统)的ROM
- 接口卡上的RAM, BIOS ROM
## 1.15 内存地址空间
- CPU将若干存储器当作一个逻辑存储器操作 ==> 内存地址空间，逻辑地址
- 每个物理存储器占有逻辑存储器的一个地址段，即一段地址空间
- 主存地址空间，显存地址空间，系统BIOS ROM地址空间，网卡BIOS ROM地址空间……
- 地址映射：逻辑地址 ==> 物理地址
- 地址映射由MMU(Memory Management Unit, 内存管理单元)负责

# 寄存器
- CPU = 运算器 + 控制器 + 寄存器
- 运算器：信息处理
- 寄存器：信息存储
- 控制器：控制各器件工作
- 内部总线：连接CPU内部各设备，传输数据
- 8086CPU所有寄存器均为16位
- 8086CPU的14个寄存器：AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW
## 2.1 通用寄存器
- AX, BX, CX, DX
- 用于存放一般性的数据
- 每个寄存器可分为两个独立的8位寄存器（兼容）
    - AX = AH + AL
    - BX = BH + BL
    - CX = CH + CL
    - DX = DH + DL
- L = low byte, H = high byte
## 2.2 字在寄存器中的存储
- 8086CPU可以一次处理两种尺寸的数据
    - 字节: byte, 由8位组成，存放于8位寄存器
    - 字: word, 由两个字节组成，高位字节、低位字节，存放于16位寄存器
- 十六进制数的一位相当于二进制数的四位
- 八进制数的一位相当于二进制数的三位
- 2^n进制数的一位相当于二进制数的n位
- 两位十六进制数相当于一个字节
# 2.3 几条汇编指令
- 进位值的丢失指进位值不能在寄存器中保存，但CPU并未真的丢失进位值
- 数据传送或运算时指令的两个操作数的位数应当一致
# 2.4 物理地址
- 物理地址：内存单元在CPU的一维线性存储空间中的唯一地址
- CPU通过地址总线向存储器传输内存单元的物理地址
- CPU内部可以有不同的方式形成内存单元的物理地址
# 2.5 16位结构的CPU
- 16位机，16位结构，字长位16位CPU的性质
    - 运算器一次最多可以处理16位数据
    - 寄存器的最大宽度为16位
    - 寄存器和运算器之间的通路为16位
- 16位CPU内部能单次处理、传输、暂时存储的信息最大长度为16位
# 8086CPU给出物理地址的方法
- 8086CPU有20根地址总线，1M寻址能力
- 8086CPU为16位结构，内部一次性处理、传输、暂存的地址为16位
- 16根地址总线的寻址能力为64K
- 8086CPU在内部用两个16为地址合成一个20位物理地址
- 地址加法器：物理地址(20 bit) = 段地址(16 bit) * 16 + 偏移地址(16 bit)
- 段地址 * 16 == 段地址左移4位(二进制位) == 段地址左移1位(十六进制位)
- n进制数左移m位，相当于乘以n^m
# 2.7 “段地址*16+偏移地址=物理地址”的本质含义
- 寻址模式：基础地址 + 偏移地址 = 物理地址
# 2.8 段的概念
- 内存本身没有分段
- CPU将内存分段，用分段的方式管理内存
- 段地址不连续，段的大小不是4位，偏移地址不是4位
- 段的起始地址一定是16的倍数（十六进制表示最低位一定是0）
- 段的大小最大为64K
- CPU可以用不同的段地址和偏移地址形成同一个物理地址
- 给定段地址，偏移地址为16位，变换范围0~FFFFH，最多寻址64K个内存单元
# 2.9 段寄存器
- 8086CPU有4个段寄存器: CS, DS, SS, ES
- segmentation
# 2.10 CS和IP
- CS: 代码段寄存器
- IP: 指令指针寄存器
- 8086CPU将CS:IP指向的信息当作指令执行
- 8086CPU启动或复位时，设置CS=FFFFH, IP=0000H
- CS:IP用于区分指令和数据
# 2.11 修改CS, IP的指令
- mov: 传送指令，不能修改CS, IP
- jmp: 转移指令，能修改CS, IP
- jmp 段地址:偏移地址
- jmp 寄存器：用寄存器的值修改IP
# 2.12 代码段
- 编程时可以根据需要将一组连续内存单元定义为一个段
- 


# 第6章 包含多个段的程序
- 可执行文件中的描述信息指明程序的第一条指令
- 可执行文件 = 程序 + 描述信息
    - 程序：源程序中的汇编指令和定义的数据
    - 描述信息：编译、连接程序对源程序中相关伪指令进行处理所得到的信息

# 第7章 更灵活的定位内存地址的方法
- and指令：逻辑与指令，按位与运算
- or指令：逻辑或指令，按位或运算
- 编码方案：约定的用怎样的信息表示现实对象的规则
- ASCII码字母大小写转换：20H
    - 转小写：or 00100000B, | 0x20
    - 转大写: and 11011111B, & 0xDF
- 偏移地址寻址 => 数组
    - [bx + idata]
    - [idata + bx]
    - idata[bx]
    - [bx].idata
- SI和DI
    - 功能与bx相近
    - 不能分为两个8位寄存器
    - [bx + si], [bx + di]
    - [bx][si], [bx][di]
    - [bx+si/di+idata]
    - [idata+si/di+bx]
    - idata[bx][si/di]
    - [bx].idata[si/di]
    - [bx][si/di].idata
# 第8章 数据处理的两个基本问题
- 数据位置，数据长度
- 4个寄存器可用于"[...]"内存单元寻址: bx, si, di, bp
- 4个寄存器可以单独出现或以4种组合出现
    - bx + si
    - bx + di
    - bp + si
    - bp + di
- 错误的组合
    - bx + bp
    - si + di
- bx的缺省段地址是ds，bp的缺省段地址是ss
- 机器指令关心指令执行的前一刻，将要处理数据的位置
- 所需处理数据的3个位置
    - CPU内部
    - 内存
    - 端口
- 汇编语言中用3个概念表达数据的位置
    - 立即数：机器指令中的数据，执行前在CPU的指令缓冲器中
    - 寄存器：汇编指令中给出寄存器名，执行前在CPU的寄存器中
    - 段地址(SA)和偏移地址(EA)：指令要处理的数据在内存中，[...]
- 寻址方式分类
    - 直接寻址
    - 寄存器间接寻址
    - 寄存器相对寻址
    - 基址变址寻址
    - 相对基址变址寻址
- 指明指令处理的数据是子操作还是字节操作
    - 通过寄存器名指明要处理数据的长度
    - 操作符"word/byte ptr"
    - push指令只进行字操作
- div指令：除法指令

|除数|被除数|商|余数|
|-|-|-|-|
|8 bit   |16 bit, ax   |8 bit, al   |8 bit, ah   |
|16 bit   |32 bit, dx high, ax low   |16 bit, ax   |16 bit, dx   |

- 伪指令dd
    - db: 定义字节型数据
    - dw: 定义字型数据
    - dd: 定义双字型数据(dword, double word)
- dup操作符：与db, dw, dd等数据定于伪指令配合使用，用于数据的重复
- db/dw/dd 重复次数 dup (重复的字节/字/双字型数据)

# 第9章 转移指令的原理
- 转移指令：修改IP，或同时修改CS和IP的指令
    - 段内转移：只修改IP
        - 短转移：IP的修改范围为-128~127
        - 近转移：IP的修改范围为-32768~32767
    - 段间转移：同时修改CS和IP
- 8086CPU的转移指令分类
    - 无条件转移指令(jmp)
    - 条件转移指令
    - 循环指令(loop)
    - 过程
    - 中断
- offset操作符：取得标号的偏移地址
- jmp指令
- jmp short label
    - 段内短转移, 8位位移
    - 机器码2 byte: EB + 8 bit offset
    - 汇编指令中包含转移的目的地址
    - 机器指令中不包含转移的目的地址
    - 机器指令中包含转移的位移
    - 位移由编译程序在编译时计算
    - 负数用补码表示
- jmp near ptr label
    - 段内近转移，16位位移
    - 位移 = 标号地址 - jmp指令后第一个字节的地址
- jmp far ptr label
    - 段间转移，远转移
    - 用标号的段地址和偏移地址修改CS和IP
    - 机器指令中包含转移的目的地址
    - 机器指令：EA 偏移地址 段地址(低地址偏移地址，高地址段地址)
- jmp 16 bit register
    - 转移的目的地址在寄存器中
- jmp word ptr 内存单元地址（段内转移）
    - 转移地址在内存中，1个字，目的偏移地址
- jmp dword ptr 内存单元地址（段间转移）
    - 转移地址在内存中，2个字，高地址目的段地址，低地址目的偏移地址
- jcxz指令
    - 有条件转移指令
    - 短转移，IP修改范围-128~127
    - 机器码中包含转移的位移而非目的地址
    - jcxz label: 若CX为0，则转移到标号，否则顺序执行
    - jcxz label <==> if(cx==0) jmp short label; 
- loop指令
    - 循环指令，短转移，IP修改范围-128~127
    - loop label <==> --cx; if(cx != 0) jmp short label;
- 根据位移进行转移 => 可重定位
- 转移范围超界 => 编译器在编译时报错

# 第10章 CALL和RET指令
- call和ret指令：转移指令，修改IP或同时修改CS和IP
- ret <==> pop IP
- retf <==> 
    - pop IP    
    - pop CS
- call指令的两步操作
    - 将当前IP或CS和IP压入栈中
    - 转移
- call指令不能实现短转移
- call lebel
    - 段内近转移，转移位移在指令中
    - push IP
    - jmp near ptr label
- call far ptr label
    - 段间转移，转移目的地址在指令中
    - push CS
    - push IP
    - jmp far ptr label
- call 16 bit register
    - 转移目的地址在寄存器中
    - push IP
    - jmp 16 bit register
- call word ptr address
    - 转移地址在内存中
    - push IP
    - jmp word ptr address
- call dword ptr address
    - push CS
    - push IP
    - jmp dword ptr address
- mul指令：乘法指令

|乘数|乘数|乘积|
|-|-|-|
|al   |8 bit register or memory unit   |16 bit, ax   |
|ax   |16 bit register or memory uint   |32 bit, high dx, low ax   |

- call和ret指令支持汇编语言编程的模块化程序设计
- 子程序的参数和结果的传递
    - 寄存器
    - 内存存储批量数据，寄存器存储内存首地址
    - 栈
- 寄存器冲突：主程序和子程序使用同一个寄存器
    - 子程序开始时保存所有用到的寄存器的内容，返回前恢复
    - 可以用栈保存寄存器中数据
- 子程序标准框架
    - 子程序使用的寄存器入栈
    - 子程序内容
    - 子程序使用的寄存器出栈
    - 返回(ret, retf)

# 第11章 标志寄存器
- 标志寄存器的3种作用
    - 存储相关指令的某些执行结果
    - 为CPU执行相关指令提供行为依据
    - 控制CPU的相关工作方式
- flag寄存器按位起作用，每一位都有专门的含义
    - 1, 3, 5, 12, 13, 14, 15位在8086CPU中未使用，不具有任何含义
    - 0, 2, 4, 6, 7, 8, 9, 10分别为CF, PF, AF, ZF, SF, TF, IF, DF, OF标志位

|标志|flag bit|name|meaning|
|-|-|-|-|
|ZF   |6   |零标志位   |指令执行结果是否为0   |
|PF   |2   |奇偶标志位   |指令执行结果的中1的位数是否为偶数   |
|SF   |7   |符号标志位   |指令执行结果是否为负   |
|CF   |0   |进位标志位   |无符号数运算结果的最高有效位向更高位的进位值（加法）或从跟高位的借位值（减法）   |
|OF   |11   |溢出标志位   |有符号数运算结果是否溢出   |
|df   |10 |方向标志位   |每次操作后si, di递增(df = 0)/递减(df = 1)   |

| instruction|name|指令格式|指令功能|
|-|-|-|-|
|abc   |带进位加法指令   |abc _1, _2   |_1 = _1 + _2 + CF   |
|sbb   |带借位减法指令   |sbb _1, _2   |_1 = _1 - _2 - CF   |
|cmp   |比较指令   |cmp _1, _2   |_1 - _2  |

|cmp ax, bx|无符号数比较|有符号数比较|
|-|-|-|
|ax = bx   |zf = 1   |zf = 1|
|ax != bx   |zf = 0   |zf = 0   |
|ax < bx   |cf = 1   |(of = 0 and sf = 1) or (of = 1 and sf = 0)   |
|ax >= bx   |cf = 0   |of = 0 and sf = 0   |
|ax > bx   |zf = 0 and cf = 0   |of = 1 and sf = 1   |
|ax <= bx   |zf = 1 or cf = 1   ||

- 检测比较结果的条件转移指令
- e: equal, b: blow, a: above, n: not
- 与cmp指令配合使用，不再考虑cmp对标志位的影响和je等对标志位的使用

|指令|含义|检测的标志位|
|-|-|-|
|je   |等于则转移   |zf = 1   |
|jne   |不等于则转移   |zf = 0   |
|jb   |低于则转移   |cf = 1   |
|jnb   |不低于则转移   |cf = 0   |
|ja   |高于则转移   |cf = 0 and zf = 0   |
|jnb   |不高于则转移   |cf = 1 or zf = 1   |

- DF标志
- cld指令：将标志寄存器的df位置0
- std指令：将标志寄存器的df位置1
- 串传送指令
    - movsb: mov es:[di], byte ptr ds:[si]; inc/dec si; inc/dec di
    - movsw: mov es:[di], word ptr ds:[si]; add/sub si, 2; add/sub di, 2
- rep instruction: s: instruction; loop s
- rep movsb/movsw
- pushf/popf: 标志寄存器的值入栈/出栈

# 第12章 内中断
- CPU能执行完当前指令后，检测来自CPU内部或外部的中断信息并立即处理
- 中断：CPU不继续刚执行完的指令向下执行，转而处理中断信息

|中断源|中断类型码|
|-|-|
|除法错误   |0   |
|单步执行   |1   |
|执行into指令   |4   |
|执行int指令   |n(int指令格式为int n, n为字节型立即数)   |

- 中断处理程序
- CPU用8位中断类型码通过中断向量表定位中断处理程序的入口地址
- 中断向量：中断处理程序的入口地址，占2字，高位段地址，低位偏移地址，共256个
- 8086PC机指定中断向量表放在内存地址0处，0000:0000~0000:03FF共1024个内存单元
- 中断过程：CPU硬件自动完成的，用中断类型码找到中断向量并设置CS和IP的工作过程
- 8086CPU收到中断信息后引发的中断过程
    - 从中断信息中获取中断类型码N
    - 标志寄存器值入栈
    - 设置标志寄存器第8位TF和第9位IF值为0
    - CS值入栈
    - IP值入栈
    - 内存地址N * 4和N * 4 + 2的字单元的值设置IP和CS
- 中断处理程序的步骤
    - 保存用到的寄存器
    - 处理中断
    - 恢复用到的寄存器
    - iret指令返回
- iret: pop IP; pop CS; popf
- 单步中断：TF=1则产生单步中断，执行中断过程，用于单步调试
- 执行单步处理程序前需要将TF置0，否则无限循环执行单步处理程序的第一条指令
- 响应中断的特殊情况：连续设置ss和sp的值

# 第13章 int指令
- int n, n为中断类型码
- BIOS(基本输入输出系统)
    - 硬件系统的检测和初始化程序
    - 外部中断和内部中断的中断例程
    - 用于对硬件设备进行I/O操作的中断例程
    - 其他和硬件系统相关的中断例程
- DOS提供的中断例程是操作系统向程序员提供的编程资源
- BIOS和DOS中断例程的安装过程
    - 开机后，CPU加电，初始化cs=0FFFFH, ip=0, 从FFFF:0开始执行程序，FFFF:0是跳转指令，转去执行BIOS中的硬件系统检测和初始化程序
    - 初始化程序建立BIOS支持的中断向量，将BIOS提供的中断例程入口登记在中断向量表中（不需要安装，固化在ROM中）
    - 调用int 19h引导操作系统，计算机的控制移交DOS
    - DOS启动后，除其他工作，还将DOS提供的中断例程装入内存，建立中断向量
- BIOS和DOS提供的中断例程用ah传递内部子程序的编号
- int 21h是DOS提供的中断例程
- int 21h中断例程的4ch号功能：程序返回

# 第14章 端口
- 端口是芯片上的、与CPU总线相连、可以由CPU读写的寄存器
- 端口地址，端口地址空间
- CPU可以直接读写3种数据
    - CPU内部寄存器
    - 内存单元
    - 端口(芯片寄存器)
- 端口读写指令
    - in: 从端口读取数据
    - out: 往端口写入数据
    - 只能使用ax或al存放从端口读入或发送到端口的数据
- CMOS RAM芯片
    - 包含一个实时钟和一个128存储单元的RAM存储器
    - 电池供电，关机后实时钟正常工作，RAM信息不丢失
    - 0~0dh保存时间信息，其余大部分单元保存系统配置信息，系统启动时BIOS使用
    - 2个端口，端口地址70h和71h
    - 70h: 地址端口，存放要访问的CMOS RAM单元地址
    - 71h: 数据端口，存放读取或写入的70h端口指向的RAM单元的数据
- shl和shr指令：逻辑移位指令
    - 寄存器或内存单元中的数据左/右移一位
    - 移出的位写入CF
    - 最低位/最高位补0

# 第15章 外中断
- CPU通过接口芯片上的端口和外部设备联系
- 外中断源
    - 可屏蔽中断：IF=0时不响应可屏蔽中断
    - 不可屏蔽中断：中断类型码为2，中断过程不需要中断类型码
- 几乎所有外设触发的中断都是可屏蔽中断
- CPU在硬件层面访问所有的中断位，并行瞬间完成
- 8086CPU的指令系统
    - 数据传送指令：单个数据传送
    - 算术运算指令
    - 逻辑指令
    - 转移指令：无条件，条件，循环，过程，中断
    - 处理机控制指令：设置标志寄存器或其他处理机状态
    - 串处理指令：处理内存中批量数据

# 第16章 直接定址表
- 地址标号：只表示地址
- 数据标号：标记数据的地址和单元长度 ==> 相当于变量和数组
- 数据标号不加":"
- 若在代码段中使用数据标号访问数据，需用伪指令assume将标号所在的段和一个段寄存器联系，否则编译器编译时无法确定标号的段地址在哪个寄存器中
- assume并不会真的在段寄存器中存放段地址，仅供编译器使用
- 直接定址表：在两个数据集之间建立映射关系，通过查表直接得到结果
- 程序入口地址的直接定址表（多个子程序）

# 第17章 使用BIOS进行键盘输入和磁盘读写
- int 9中断例程处理键盘输入
- int 16h中断例程读取键盘缓冲区，若空则循环等待
- int 13h中断例程读写磁盘

# 综合研究
- C程序必须从main函数开始是C语言的规定
- C语言开发系统提供的.obj文件包含初始化和返回程序，调用main函数
- Intel系列微处理器的3种工作模式
    - 实模式：工作方式相当于1个8086
    - 保护模式：支持多任务环境，建立保护机制
    - 虚拟8086模式：从保护模式切换，在保护模式下运行一个或多个8086程序
- PC机开始时CPU工作在实模式下
    - 若操作系统为DOS，DOS加载后CPU仍以实模式工作
    - 若操作系统为Windows，Windows加载后由Windows将CPU切换至保护模式
    - 若在Windows中运行DOS程序，Windows将CPU切换至虚拟8086模式下运行程序
- 有符号数的编码
    - 原码：最高位表示符号(0为正，1为负)，其他位表示数值
    - 反码：正数与原码相同，负数为正数取反
    - 补码：正数与原码相同，负数为正数取反加1
- 正数的原码、反码、补码相同
- 正数与负数原码的数值位相同
- 负数的原码、反码、补码的符号位为1
- 负数的反码的数值位为原码的数值位按位取反
- 原码和反码都存在0重码的问题
- 负数的补码的数值位为反码的数值位加1
- 正数取反加1后为负数的补码
- 负数的补码减1后取反为正数
- 负数的补码取反后加1为正数
- 取反加1 <==> 减1取反
- 减法用加法代替 ==> 补码与补码按位相加的结果为和的补码，无论正负

|编码|原码|反码|补码|
|-|-|-|-|
|00000000b   | 0  | 0  | 0  |
|01111111b   | 127  | 127  | 127  |
|10000000b   | -0  | -127  | -128  |
|11111111b   | -127  | -0  | -1  |

- 用栈传递参数
    - 高级语言编译器的工作原理
    - 调用者将传递给子程序的参数压栈，子程序从栈中获取参数
    - ret n: pop ip; add sp, n
