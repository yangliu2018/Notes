# 第2章 变量和基本类型
C++是静态数据类型语言，类型检查发生在编译时，编译器必须知道程序中每一个变量的数据类型  
C++语言的基本形态：内置数据类型、运算符、程序流控制语句  
类类型(class type)：C++最重要的语法特征是类  
 
## 2.1 基本内置类型
## 2.2 变量
## 2.3 复合类型
## 2.4 const限定符
## 2.5 处理类型
## 2.6 自定义数据结构



## 2.1 基本内置类型
### 2.1.1 算术类型
基本数据类型 = 算术类型 + 空类型  
算术类型 = 整型 + 浮点型  
整型 = 字符型 + 整数型 + 布尔类型(bool)  
浮点型 = 单精度(float) + 双精度(double) + 扩展精度(long double)
字符型 = 

比特(bit): 非0即1，计算机以比特序列存储数据  
字节(byte): 可寻址的最小内存块  
字(word): 存储的基本单元  
1 byte = 8 bit  
1 word = 4 byte = 32 bit (32位机器)  
1 word = 8 byte = 64 bit (64位机器)  
内存中字节(byte)与地址(address)一一对应

#### 带符号类型和无符号类型
字符型 = char + signed char + unsigned char  
字符型有3种，但字符型的表现形式只有2种  
char会表现为signed char与unsigned char中的一种，由编译器决定  

### 2.1.2 类型转换
对象的类型定义了对象能包含的数据和能参与的运算，类型转换是大多数类型支持的一种运算  

当一个算术表达式既有无符号数又有int值时，int值会被转换成无符号数  
含有无符号数的算术表达式的结果也是无符号数  
无符号数不会小于0会影响循环条件的写法  

### 2.1.3 字面值常量(literal)
字面值常量的形式和值确定其数据类型  
整型字面值
* 十进制 整数
* 八进制 "0"开头的整数
* 十六进制 "0x"开头的整数

浮点型字面值
* 小数
* 科学计数法，指数部分用"E"或"e"标识

字符和字符串字面值
* 单括号''
* 双括号"", 常量字符构成的数组(array)
* 字符串字面值的实际长度比其内容多1，结尾处有空字符'\0'
* 多行书写的字符串字面值：多个字符串字面值仅以空格、缩进、换行符分隔，则其为一个整体
 
#### 转义序列(escape sequence)
程序员不可直接使用的两类字符
* 不可打印(nonprintable)字符：空格或控制字符，没有可视的图符
* C++语言中有特殊含义的字符：单引号、双引号、问号、反斜线

指定字面值的类型
* 前缀
  - L: 宽字符型字面值，类型wchar_t
  - u8: utf-8字符串字面值
* 后缀
  - ULL: 无符号整型字面值，类型unsigned long long
  - F: 单精度浮点型字面值，类型float
  - L: 扩展精度浮点型字面值，类型long double(小写字母l与数字1容易混淆，不推荐)

布尔类型字面值：true, false

指针字面值：nullptr

## 2.2 变量
### 2.2.1 变量定义
类型说明符(type specifier)  
初始值  
初始化
* 列表初始化
* 默认初始化
* 不被初始化
 
建议初始化每一个内置类型的变量

### 2.2.2 变量声明和定义的关系
分离式编译(separate compilation): 将程序分为若干文件，每个文件可以被独立编译    
声明(declaration): 使名字被程序所知，关键字"extern"  
定义(definition): 创建与名字关联的实体  

### 2.2.3 标识符(identifier)
标识符 = 字母 + 数字 + 下划线，字母或下划线开头，无长度限制，大小写敏感


## 2.3 复合类型

NULL: 预处理变量(prepocessor variable)，在头文件cstdlib中，不属于命名空间std
nullptr: 字面值常量

void* 指针：可以存放任意对象的地址，但不知道对象的类型，无法访问内存空间中的对象


### 2.3.3 理解复合类型的声明
引用本身不是一个对象，不能定义指向引用的指针  
指针本身是一个对象，存在对指针的引用  

## 2.4 const限定符
const对象必须初始化，创建后值不可改变  
默认状态下，const对象仅在文件内有效  
多文件共享同一个const对象：声明和定义前都加extern关键字

### 2.4.1 const的引用
对常量的引用(reference to const)  
对const的引用可能引用一个非const的对象  

### 2.4.2 指针和const
指向常量的指针(pointer to const)  
常量指针(const pointer)必须初始化

### 2.4.3 顶层const
顶层const(top_level const): 指针本身是常量
底层const(low_level const): 指针指向的对象是常量

### 2.4.4 constexpr和常量表达式(const expression)
常量表达式：值不会改变且在编译过程就能得到计算结果的表达式  
字面值属于常量表达式  
常量表达式初始化的const对象是常量表达式  
const对象不一定是常量表达式(const对象的值可以运行时确定)  

#### constexpr变量
将变量声明为constexpr类型以便编译器验证变量的值是否是一个常量表达式  
声明为constexpr的变量一定是一个常量，且必须用常量表达式初始化(或者constexpr函数)

#### 字面值类型(literal type)
只有字面值类型的对象才可以定义成constexpr  
指针和引用可以定义成constexpr，但初始值受到严格限制  
constexpr指针的初始值必须为nullptr或者0或者存储于某个固定地址中的对象  
constexpr指针一般不可以指向函数体内定义的变量：函数体内定义的变量一般并非存放在固定地址中  
函数可以定义有效范围超出函数本身的变量，与定义在函数体外的变量一样有固定地址，可以用于初始化constexpr指针或引用

#### 指针和constexpr
constexpr声明中如果定义一个指针，限定符constexpr仅对指针有效，而与指针指向的对象无关  
constexpr与const可以同时使用

## 2.5 处理类型

### 2.5.1 类型别名
typedef

### 2.5.2 auto类型说明符
编译器自动识别数据类型

### 2.5.3 decltype类型指示符
选择并返回操作数的数据类型，编译器分析表达式并得到其类型，但不计算表达式的值

## 2.6 自定义数据结构
自定义类
