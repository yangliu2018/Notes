# 离散数学及其应用 第7版

## 第6章 计数

### 生成排列和组合
- 排列的字典顺序
```math
a_1 a_2 ... a_n < b_1 b_2 ... b_n, 当且仅当对于某个k, 1 \leq k \leq n, a_1 = b_1, a_2 = b_2, ..., a_{k-1} = b_{k-1}, 且a_k < b_k 
```
- 字符串的比较与排列的字典顺序一致：从排列起始的第一个不相等的元素决定排列的大小
- 排列生成算法：从一个给定排列按照字典顺序构造下一个排列
    - 给定排列$a_1 a_2 ... a_n$
    - 若$a_{n - 1} < a_n$, 则交换$a_{n-1}$和$a_n$，结束
    - 若$a_{n - 1} > a_n$
        - 若$a_{n-2} < a_{n-1}$
            - $a_{n-2} < a_{n} < a_{n-1} \Rightarrow a_n a_{n-2} a_{n-1}$
            - $a_n < a_{n-2} < a_{n-1} \Rightarrow a_{n-1} a_n a_{n-2}$
        - 若$s_{n-2} > a_{n-1}$，继续比较$a_{n-3}$
- 排列$a_1 a_2 ... a_n$中，$a_{k+1} a_{k+2} .. a_n$是降序，且$a_k < a_{k+1}$，则该排列的下一个排列为：将$a_k$与$a_{k+1}, a_{k+2}, ..., a_n$中大于$a_k$的最小元素交换位置（$a_{k+1}, a_{k+2}, ..., a_n$保持降序），然后将$a_{k+1}, a_{k+2}, ..., a_n$逆序（$a_{k+1}, a_{k+2}, ..., a_n$变为升序）
- 集合的r组合：n个元素的集合中的r个元素的子集
    - 集合{1, 2, 3, ..., n}
    - 第一个r组合是{1, 2, ..., r}
    - 最后一个r组合是{n-r+1, n-r, ..., n}
    - 下一个r组合

## 第7章 离散概率
- 用概率论的思想和技巧确定算法的平均复杂度
- 概率算法可用于解决许多不容易或不可能用确定性算法求解的问题
- 概率算法做一次或多次随机选择，在相同的输入下可能导致不同的输出结果
### 离散概率引论
- 试验：从一组可能的结果中得出一个结果的过程
- 样本空间：可能结果的集合
- 事件：样本空间的子集
- 结果具有相等可能性的样本空间中具有有限多个可能结果的事件的概率：概率 = 事件 / 样本空间
- 概率分布：样本空间的所有事件的集合上的函数
- 条件概率：p(E|F), 给定事件F的条件下事件E的概率
- 独立性，两两相互独立
- 伯努利试验，二项分布
- 随机变量
#### 蒙特卡罗算法
- 概率算法：在一步或多步做随机选择的算法
- 蒙特卡罗算法是关于判定问题的一类特殊的概率算法
- 蒙特卡罗算法对于问题总能得到答案，但这些答案可能存在很小的出错概率，算法执行足够多的计算时可降低答案出错概率
- 蒙特卡罗算法使用一系列的测试
    - 每一步可能的回答
        - 真：答案真，不需要进一步迭代（某个个体的真等于整体的真）
        - 不知道：答案可能真也可能假，继续迭代（某个个体的假不等于整体的假，所有个体的假才等于整体的假）
        - S = A1 || A2 || ... || An
    - 多次迭代后
        - 如果存在某次迭代的答案为“真”，则最后的答案为“真”
        - 如果每次迭代的答案均为“不知道”，则最后的答案为“假”
- 答案为“真”时
    - 设p为单次测试回答“真”的概率，则1-p为单次测试回答“不知道"的概率
    - n次测试最后回答“假”的概率为$(1-p)^n$，随测试次数增加无限接近于0
    - 故答案为“真”时蒙特卡罗算法回答“真”的概率接近1
- 答案为“假”时
    - 所有个体均为假，每次测试必然回答“不知道”，算法最终必定回答“假”
- 质量控制
    - 判定问题：该批芯片是否未被制造商测试
    - 未测试批次的芯片良率0.9,制造商测试后的芯片良率为1
    - 如果单张芯片不合格，则该批芯片未被制造商测试
    - 如果连续随机选择k张芯片均合格，则该批芯片已被开发商测试
    - 已测试的批次会连续回答“不知道”，最终答案“假”
    - 未测试的批次连续回答k个“不知道”的概率为$0.9^k$，这种情况下出错
    - 出错概率与芯片片数n无关
- 蒙特卡洛算法的时间复杂度为常数O(1)
- 素数的概率测试
    - 判定问题：n是否为合数
    - 合数通过米勒测试的概率小于1/4
    - 随机选择整数b(1<b<n)，判断n能偶通过以b为底的米勒测试，k次迭代
    - n是合数但算法回答n是素数的概率为$(1/4)^k$
    - 可用于生成大素数和公共秘钥密码系统

### 贝叶斯定理
```math
p(F|E) = \cfrac{p(E|F)P(F)}{P(E)} = \cfrac{p(E|F)p(F)}{P(E|F)p(F) + p(E|\bar{F})p(\bar{F}))}
```
- 贝叶斯过滤器
- 贝叶斯垃圾邮件过滤器

### 期望值和方差
- 随机变量的期望值：随机变量的值以该值出现的概率为权的加权平均
- 期望是随机变量分布的位置，方差是随机变量分布的离散程度
- 切比雪夫不等式


## 第10章 图
- 图是由顶点和连接顶点的边构成的离散结构
- 图的分类
    - 有向图，无向图：图的边是否有方向
    - 无限图，有限图：顶点集合边集是否无限
    - 简单图，多重图：是否存在多重边连接同一对顶点，多重度
    - 伪图：包含环或存在多重边连接同一对顶点或同一个顶点的图
        - 环：将一个顶点连接到它自身的边
    - 有向图：简单有向图，多重有向图，多重有向边
    - 混合图：有些边有向，有些边无向
- 定义
    - 一个图G = (V, E)由顶点/结点的非空集V和边的集合E构成；每条边有一个或两个顶点与它相连，这样的顶点称为边的端点；边连接它的端点
    - 一个有向图G = (V, E)由非空顶点集V和有向边/弧集E组成；每条有向边与一个有序顶点对相关联；有序对(u, v)向关联的有向边开始于u，结束于v
- 术语
    - 两个顶点邻接/相邻，边e关联顶点u和v，边e连接u和v
    - 顶点v的邻居：顶点v的所有相邻顶点的集合，记为N(v)
    - A是V的子集，N(A)表示图G中至少和A中一个顶点相邻的所有顶点的集合
    - 顶点的度：无向图中与该顶点关联的边的数目，环双倍贡献，记为deg(v)
    - 顶点的入度和出度：有向图中以v为终点/起点的边的数目，记为deg-(v), deg+(v)
    - 孤立：度为0的顶点
    - 悬挂：度为1的顶点
- 定理
    - 握手定理 2m = sum(deg(v)), G = (V, E)是有m条边的无向图
    - 无向图有偶数个度为奇数的顶点
    - 有向图，sum(deg-(v)) = sum(deg+(v)) = |E|
- 简单图
    - 完全图 K_n
    - 圈图 C_n
    - 轮图 W_n
    - 立方体图 Q_n
- 二分图：G中的任一条边分别连接V1和V2中的两个顶点，V1或V2内部的顶点无边连接
- 完全二分图 K_(m, n)：两个顶点之间有边当且仅当两个顶点分别属于两个顶点集
- 二分图和匹配
    - 任务分配
    - 匹配，未匹配，最大匹配，完全匹配
- 特殊类型图的应用
    - 局域网
        - 星形拓扑 K_(1, n)
        - 环形拓扑 C_n
        - 混合拓扑 W_n
    - 并行计算的互连网络
        - 每对处理器双向连接 K_n
        - 线性阵列
        - 栅格网络/二维阵列
        - 超立方体：每个处理器都有到其他m个处理器的双向连接
- 从旧图构造新图
    - 子图，真子图，
    - 删除或增加图的边
    - 边的收缩：删除边同时合并该边连接的顶点
    - 从图中删除顶点：删除顶点同时删除该顶点关联的边
    - 图的并集：并图

### 图的表示和图的同构
- 邻接表：顶点 -> 该顶点邻接的所有顶点
    - 不支持多重边
- 邻接矩阵 A = [a_ij] 顶点-顶点关系
    - 顶点u到顶点v的边的数目
    - 简单图的邻接矩阵是0-1矩阵
    - 无向图的邻接矩阵对称，a_ij = a_ji
    - 邻接矩阵可用于表示带环和多重边的无向图或有向图
- 关联矩阵 M = [m_ij] 顶点-边关系
    - 边ej是否关联顶点vi
- 同构：两个图的顶点之间具有保持相邻关系的一一对应
- 图形不变量：图的同构中保持不变的属性
- 图同构算法
- 图同构的应用
    - 分子图
    - 电路图

### 连通性
- 通路：边的序列
- 连通：图的每一对不同顶点之间都存在通路
- 连通分支：极大连通子图，连通子图且不是另一个连通子图的真子图
- 割点/关节点，割边/桥
- 点连通性，不可分割图
- 强连通，弱连通

### 最短通路问题

## 第11章 树
- 树是没有简单回路的连通无向图
- 森林是没有简单回路的无向图（可能不连通），森林的连通分支是数
- 一个无向图是树当且仅当它的每对顶点之间存在唯一简单通路
- 有根树是指定一个顶点作为根且每条边的方向都离开根的树
    - 父母，孩子，兄弟，祖先，树叶，内点
- N叉树，二叉树
- 有序根树：每个内点的孩子都排序的有根树
- 树形连接并行处理系统
- 平衡的m叉树
- m叉树中树叶数目的界
### 树的应用
- 二叉搜索树
- 决策树
- 前缀码
- 博弈树
### 树的遍历

### 生成树
- 简单图G的生成树是包含G的所有顶点的G的子图
- 简单图是连通的当且仅当它有生成树
- 建立简单图的生成树
    - 搜索简单回路，删除简单回路的边；低效
    - 深度优先搜索/回溯
    - 宽度优先搜索
- 回溯的应用
    - 决策树：每个内点表示一个决策，每个树叶表示一个可行解，回溯法使用深度优先搜索在决策树中搜索可行解
    - 图着色：给某个顶点尝试着某种颜色，下个顶点继续着色，如果无法继续则回溯，改为其他颜色
    - N皇后问题：在N*N的棋盘上放置N个皇后，是的任何两个皇后不能相互攻击
        - (x1, y1), (x2, y2)
        - x1 != x2, y1 != y2, x1 + y1 != x2 + y2; x1 - y1 != x2 - y2
    - 子集之和：给定正整数集合x1, x2, ..., xn, 求该集合的子集使其和为M
        - 每次添加一个元素进入子集，若和小于M则继续，若和大于M则回溯，移除元素
- 有向图中的深度优先搜索
    - 输出不一定是生成树，可能是森林
    - 网络蜘蛛

### 最小生成树
- 连通加权图里的最小生成树是具有边的权之和最小的生成树
- 普林算法
    - 选择带最小权的边，加入生成树
    - 依次向树里添加与已在树里的顶点关联的且不与已在树里的边形成简单回路的权最小的边
    - 有n个顶点，添加n-1条边时终止
- 克鲁斯卡尔算法
    - 依次选择权最小的任一边且添加入T时不形成简单回路，将e添加进T


## 第13章 计算模型
- 计算模型解决的问题
    - 计算机能否完成某个任务
    - 计算机如何执行这个任务
- 3种类型的计算模型
    - 文法
    - 有限状态机
    - 图灵机

### 语言和文法
- 概念
    - 语法：语言的形式
    - 语义：语言的含义
    - 自然语言：语法规则复杂模糊
    - 形式语言：由一组意义明确的语法规则定义
- 文法解决的问题
    - 如何确定一组单词是否组合成形式语言的一个有效句子
    - 如何产生形式语言的一个有效句子
- 文法的概念
    - 词汇表：由称为符号的元素构成的有限非空集合, V
    - 终结符：词汇表中不能被其他符号替换的某些元素, T
    - 非终结符：词汇表中能用其他符号替换的某些元素, N
    - 初始符：从该特殊元素开始定义其他符号, S
    - 由词汇表V中的元素构成的所有串的集合记为V^*
    - 产生式：指明V^*中的串能被什么样的串代替的规则
- 短语结构文法的类型
    - 0型文法：对产生式无限制
    - 1型文法：上下文有关文法 -> 上下文有关语言
        - 产生式w1->w2
            - w1 = lAr, w2 = lwr
            - A是一个非终结符
            - l和r是0或多个终结符或非终结符构成的串
            - w是终结符或非终结符构成的非空串
        - 产生式S->λ，S不能出现在任何其他产生式的右边
    - 2型文法：上下文无关文法 -> 上下文无关语言
        - 产生式w1->w2, 其中w1是一个单个的非终结符的符号
    - 3型文法：正则文法 -> 正则语言
        - 产生式w1->w2
            - 满足w1=A且w2=aB或w2=a，其中A和B是非终结符，a是终结符
            - 或者满身w1=S, w2=λ
- 非缔约
    - 非缔约的产生式：产生式w1->w2中w1的长度小于等于w2
    - 非缔约的/单调的文法：该文法的所有产生式均非缔约
- 派生树/语法分析树
    - 上下文无关语言的派生可以用有序根树表示成图形
    - 根：初始符
    - 内部节点：非终结符
    - 叶结点：终结符
    - 自顶向下的语法分析
    - 自底向上的语法分析
- 巴克斯-诺尔范式(BNF): 描述编程语言的语法规则
    - 2型文法中产生式的左边都是单个非终结符
    - 合并左侧相同的产生式，用 | 隔开多个产生式的右侧
    - 用::=代替->，用<>将非终结符括起来
```c
// 带符号十进制正数的产生式的巴克斯-诺尔范式
<带符号整数> ::= <符号><整数>
<符号> ::= +|-
<整数> ::= <数字>|<数字><整数>
<数字> ::= 0|1|2|3|4|5|6|7|8|9
```

### 带输出的有限状态机
- 有限状态机
    - 有限的状态集合，其中一个指定为初始状态
    - 输入字母表
    - 转移函数：每组状态和输入对应的下一个状态
- 有限状态机是许多程序的基础
    - 拼写检查，语法检查，索引或搜索大文本，语音识别
    - 采用XML和HTML等标记语言转换文本，规范计算机如何通信的网络协议
- 状态机的表示方式
    - 状态表, (状态, 输入) -> (下一个状态, 输出)
    - 状态图，边带有标号的有向图，带圈的顶点表示状态，边表示转移，边的标号表示输入和输出
- 状态机用于机器建模
    - 自动售货机
    - 输入延迟器
    - 整数加法器
    - 判断位串是否包含指定模式的机器
- 有限状态机M = (S, I, O, f, g, s0)由如下部分组成（形式化定义）
    - 一个有限的状态集合S: {state...}
    - 一个有限的输入字母表I: {input...}
    - 一个有限的输出字母表O: {output...}
    - 一个转移函数f: (state, input) -> state
    - 一个输出函数g: (state, input) -> output
    - 初始状态s0
- 单位延迟机：将输入的串延迟一定的时间量后输出
    - 记录前一个输入，每次输入时输出前一个输入
    - 状态
        - s0: 初始状态
        - s1: 前一个输入是0
        - s2: 前一个输入是1
- 整数二进制加法器
    - 输入是两个整数对应位的两个数字
    - 状态
        - s0: 初始状态，进位为0
        - s1: 进位为1
- 有限状态机M能够识别/接受输入集合L：当且仅当L中的所有元素作为输入时，M的最后一个输出位是1
- 有限状态机的类型
    - 米兰机：输出与状态之间的转移对应
    - 摩尔机：输出仅由状态决定

### 不带输出的有限状态机
- 语言识别是有限状态机的最重要应用之一
- 有限状态自动机
    - 不带输出的有限状态机
    - 不产生输出，有一个终结状态组成的集合
    - 识别一个串，当且仅当该串能将初始状态变为一个终结状态
- 有限状态自动机M = (S, I, f, s0, F)由如下部分组成（定义）
    - 一个有限的状态集合S
    - 一个有限的输入字母表I
    - 一个转移函数f
    - 一个初始状态s0
    - 一个由终结符/可接受状态构成的S的子集F
- 状态图中终结状态用双圈表示
- 转移函数的扩展
- 识别/接受：串x能将机器M从初始状态变为一个终结状态，即f(s0, x)是F的元素
- 等价：两个有限状态自动机识别相同的语言
- 设计识别特定类型串的有限状态自动机
- 自动机简化：用最少的状态构造一个邮箱状态机，使其等价于给定的有限状态自动机
    - 首先删除从开始状态使用任何输入都不可达的状态
- 非确定性的有限状态自动机
    - 确定性：对每对状态和输入，转移函数有唯一的下一个状态
    - 非确定性：对每对状态和输入，转移函数有多个可能的下一个状态
    - 可以用于判断哪些语言可以由有限状态自动机识别
- 非确定性的有限状态自动机M = (S, I, f, s0, F)由以下部分组成
    - 状态集合S
    - 输入字母表I
    - 转移函数f: S * I -> P(S), (state, input) -> state set
    - 初始状态s0
    - 由终结状态构成的S的子集F

### 语言识别
- 正则集合
    - 一个集合能够被一个有限状态自动机识别，当且仅当这个集合是以任意顺序通过对空集、空串和单字符串的连接、并或克莱因闭包构造出来的
    - 一个集合是正则的，当且仅当它可以由一个正则文法生成
    - 正则集合是有限状态机识别的语言
    - 正则集合可以用正则表达式描述
- 克莱因定理：一个集合是正则的，当且仅当它可由一个有限状态自动机识别
- 正则集合 <==> 正则语言 <==> 正则文法生成的 <==> 有限状态自动机可识别
- 更强大的机器
    - 有限状态自动机的局限：有限的存储，只能识别正则语言
    - 下推自动机：带有提供无限存储的栈的有限状态自动机
        - 识别标志：最终到达终结状态或空栈
    - 线性有界自动机：能识别上下文有关文法，不能识别短语结构文法生成的所有语言
    - 图灵机：有限状态自动机 + 两端无限的带，在带上读写，沿着带左右移动
        - 能识别短语结构文法生成的所有语言
        - 能为计算机器上执行的所有计算建模 ==> 在理论计算机科学中广泛研究

### 图灵机
- 图灵机 = 控制器 + 带
    - 控制器：任何时刻处于有限多个不同状态中的某个状态
    - 带：分成多个方格，两端无限
    - 控制器沿着带来回移动，在带上读写，并根据所读符号改变状态
- 图灵机是计算的最通用模型，图灵机能做计算机能做的任何事
- 图灵机比带有有限存储能力的真实计算机更强大
- 图灵机T = (S, I, f, s0)由下列部分组成
    - 有限状态集S
    - 包含空白字符B的字母表I
    - 部分函数f: S * I -> S * I * {R, L}
    - 初始状态s0