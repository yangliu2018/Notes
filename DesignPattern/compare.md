|Design Pattern|Usage|Implement|
|-|-|-|
|-|Creatinoal Design Pattern|-|
|Abstract Factory|创建多种类的实例|继承抽象工厂的不同具体工厂的虚方法创建继承抽象产品的不同的具体产品实例|
|Builder|复杂对象的构建和表示分离，同样的构建过程可以创建不同的表示|生成器提供构建对象的基本步骤，生成器是导向器的成员，导向器调用生成器构建对象并组织构建步骤顺序，返回构建完成的对象|
|Factory Method|创建多个派生类的实例|创建器的不同派生类的虚方法创建不同的产品|
|Prototype|拷贝原型创建新实例|原型的clone方法拷贝自身，返回拷贝构造的实例|
|Singleton|保证一个类只有一个实例|静态instance方法获取静态成员实例，私有化构造函数|
|-|Structural Design Pattern|-|
|Adapter|匹配不同类的接口|在适配器的方式中调用被适配者的方法；类适配器：多重继承，基类子对象；对象适配器：成员子对象或成员指针|
|Bridge|对象的接口与实现分离|实现是抽象的成员，抽象类的方法调用实现类的方法，抽象与实现均多态|
|Composite|简单和复合对象的树形结构，简单对象和复合对象的接口一致|复合类继承抽象组件类，并在内部维护一个子组件列表，多个具体组件实现组件类，复合类用子组件的组件类接口实现自身的组件类接口，递归复合|
|Decorator|动态添加对象而不是类的职责|装饰器继承组件接口类，并以另一个组件作为成员，动态扩展，递归装饰，装饰器用内部成员组件的操作和额外的操作实现组件接口操作，不同的派生装饰器调用装饰器基类子对象的操作，并实现不同的额外操作|
|Facade|单个类代表整个子系统，复杂子系统的简单统一接口|外观实例接收客户的处理请求，并将请求分发给适当的子系统对象|
|Flyweight|高效共享大量细粒度对象|将状态拆分为内部共享状态和外部非共享状态，共享状态对象由享元工厂创建和管理，客户创建非共享状态对象，从享元工厂获取共享状态对象的引用|
|Proxy|对象的访问控制|代理类和真实物体类继承相同的接口类，真实物体的引用是代理类的成员，接收请求后，代理类对象向真实物体对象转发请求，并可能附加操作|
|-|Behavioral Design Pattern|-|
|Chain of Responsibility|在对象链中传递请求，直到请求被某个对象处理|基类Handler中持有后继Handler的引用，基类中实现的默认请求处理方式是将请求传递给后继Handler，直到某个对象覆盖了请求处理函数并处理请求|
|Command|将命令请求封装为对象，分离调用者与接收者|接收者是命令的成员，调用者通过命令对象调用接收者的方法，回调机制的面向对象实现，函数对象|
|Interpreter|在程序中包含语言元素，解释执行重复出现的问题|从语言的角度，用多个基本操作/语法解释一个表达式/语句，构建抽象语法树，在上下文中执行表达式；抽象语法树是复合模式的实例，抽象语法树中使用享元模式共享终结符
|Iterator|顺序访问聚合对象的元素，隐藏聚合对象的内部结构|将聚合对象的访问和遍历分离至迭代器对象，迭代器可以定义不同的遍历策略，多态迭代，聚合对象负责创建相应的迭代器；创建迭代器属于工厂方法模式；外部/内部迭代器；游标|
|Mediator|中介对象封装一系列对象的交互，组内对象间不显示引用|各个对象与都与中介者通信，中介者负责请求的控制和转发，事件驱动引擎是中介者|
|Memento|不破坏封装，在对象的外部捕获、保存和恢复对象的状态|检查点和取消机制，备忘录储存原发器某时刻的内部状态，备忘录设置、获取状态的方法私有，原发器是备忘录的友元|
|Observer|一个对象状态改变时，依赖它的多个对象得到通知并自动更新|目标持有一组观察者的引用，当状态更新时通知所有观察者更新；观察者持有目标的引用，可以更新目标的状态；MVC: model: subject, view: observer|
|State|对象内部状态改变时行为也改变|状态对象是环境对象的成员，处理请求被转发给状态对象，状态对象多态可切换；TCP协议状态：open, close, listen, established|
|Strategy|封装算法，可以相互替换|策略对象是上下文对象的成员，处理请求被转发给策略对象，策略类提供算法接口，多态的策略子类实现算法；不使用多态，策略作为模板参数|
|Template Method|基类定义算法骨架，子类重定义部分算法步骤|子类调用父类的模板方法，父类的模板方法部分调用子类的操作；父类定义多个操作并提供缺省行为，模板方法中调用这些操作，子类重定义部分操作；钩子操作|
|Visitor|作用于对象结构中不同元素的不同操作，不改变元素类层次结构增加新操作|多种元素，多种访问者，每个访问者都实现访问不同元素的操作，元素接收访问者后调用该访问者访问该元素的方法|



- 代理
    - 虚拟代理：延迟创建大开销对象的占位符
    - 远程代理：不同地址空间对象的本地表示
    - 保护代理：检查访问控制权限
    - 智能代理：取代简单指针，访问对象时执行附加操作
        - 对指向的对象引用计数，无引用时释放对象
        - 首次引用持久对象时，将对象装入内存
        - 访问真实对象时，检查是否已经加锁，确保无法被其他对象改变
- C++的多态迭代器使用资源分配即初始化技术和代理模式，栈对象是堆对象的代理
- Facade是客户通过外观对象向子系统提出请求的单向协议，Mediator是多个对象通过中介者对象互相提出请求的双向协议
- 多态可以取代选择语句，执行不同导出类的虚函数
- 模板方法中子类重定义父类行为时可以用装饰器扩展父类行为
- 模板方法通常会调用工厂方法
- 模板方法使用继承改变算法的一部分，策略使用委托改变整个算法
- 迭代器访问的元素必须有相同的基类，访问者访问的元素可以由完全无关的类型
- 单分派(single-dispatch)：C++中请求执行的操作操作取决于请求名称和接收者类型
- 双分派(double-diapatch)：Visitor模式中请求执行的操作取决于请求名称和Visitor, Element两个接收者类型