### 虚函数
* 虚函数是动态绑定的，使用指针或引用的虚函数能找到实际类的对应函数，而不是定义类的函数
* 构造函数不能是虚函数；在构造函数中调用虚函数，实际执行父类的对应函数
* 析构函数可以是虚函数；复杂类结构中析构函数必须是虚函数
* 纯虚函数的作用是将类定义为抽象类，不能实例化对象
* 纯虚函数通常没有定义体，但实际上可以有
* 析构函数可以是纯虚函数，但纯虚析构函数必须有定义体
* 非纯的虚函数必须有定义体
* 派生类的override虚函数定义通常必须与父类完全一致；特例：父类返回值是指针或引用，子类override时可以返回指针或引用的派生

### 抽象语法树
* 抽象语法树(Abstract Syntax Code, AST)是源代码的抽象语法结构的树状表示，每个节点是源代码中的一种结构
* 抽象语法树的特点：不依赖具体的文法，不依赖语言的细节
* 前后文无关文法：LL(1)，LR(0)，LR(1)， LR(k) ,LALR(1)等

### 统计代码行数
* ^b*[^:b#/]+.*$
* ^(?!(\s*\*))(?!(\s*\-\-\>))(?!(\s*\<\!\-\-))(?!(\s*\n))(?!(\s*\*\/))(?!(\s*\/\*))(?!(\s*\/\/\/))(?!(\s*\/\/))(?!(\s*\}))(?!(\s*\{))(?!(\s(using))).*$

### 文件存储方式


### Most Vexing Parse
* 凡是长得像函数声明的，就是函数声明
* 



* CRTP
* The Curiously Recurring Template Pattern
* std::enable_shared_from_this

```cpp
typename... Ts
Ts&&... params
std::forward<Ts>(parames)...
*```

* 条件变量要与互斥锁一起使用
* 条件变量避免了轮询检查临界区
* 嵌套类，匿名类，局部类
* 函数不能嵌套，但可通过重载类的()方法模拟函数调用


### 线程池
一种是多个线程共享一个任务队列，用户把任务投递到该任务队列中，其他线程竞争从该队列中获取任务执行。结合boost::thread，在多个线程里面调用run方法，即可实现该线程池：
另一种是每个线程各自维护一个任务队列，用户可以选择随机或者轮训地投递任务到其中一个任务队列里面，该任务队列中的任务只由其所在的线程才能消费。这种线程池在boost的example里面也有相应的实现(io_service_pool)，基本方法是创建多个io_service对象，每个对应一个thread，代码如下：
